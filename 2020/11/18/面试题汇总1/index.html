<!DOCTYPE html>
<html lang="zh-Hans">
<head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>面试题汇总1 - Along-Blog</title>
  

  
    <meta name="description" content="CSS3,HTML5 新增属性Css3:border-color 边框颜色, box-shadow 边框阴影, back ground-size 背景图片大小(cover,contain) , text-shadow,文本阴影 transform 变换, animation 动画, transition 过渡
H...">
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="Along-Blog">
  

  <!-- import meta -->
  

  <!-- link -->
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

</head>

<body>
  

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  <div id="l_body">
    <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">ALong-Blog</p>
    
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

    <div id='safearea'>
      <div class='body-wrapper' id="pjax-container">
        

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        面试题汇总1
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="">
    <p>请设置文章作者</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Nov 18, 2020</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="面试题汇总1" data-path="/2020/11/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB1/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  <h2 id="CSS3-HTML5-新增属性"><a href="#CSS3-HTML5-新增属性" class="headerlink" title="CSS3,HTML5 新增属性"></a>CSS3,HTML5 新增属性</h2><p>Css3:border-color 边框颜色, box-shadow 边框阴影, back ground-size 背景图片大小(cover,contain) , text-shadow,文本阴影 transform 变换, animation 动画, transition 过渡</p>
<p>Html5:video ,audio, localStorage 和 sessionStorage , 新增表单类型标签:email url number , 表单属性 form , 语义化标签:article , aside , header , footer</p>
<a id="more"></a>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>块级格式上下文</p>
<p>css 的一个布局概念 ,是一个<strong>独立的区域</strong>,在这个容器中按照一定规则进行摆放,并且不会影响其他环境中的物品</p>
<p><strong>如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。</strong></p>
<p>浮动元素会创建 BFC，则浮动元素内部子元素主要受该浮动元素影响，所以<strong>两个浮动元素之间是互不影响的</strong></p>
<h2 id="Es6-新特性"><a href="#Es6-新特性" class="headerlink" title="Es6 新特性"></a>Es6 新特性</h2><p>箭头函数 模板字符串`` promise let const 解构赋值 扩展运算符 class 类</p>
<h2 id="数据类型有哪几种"><a href="#数据类型有哪几种" class="headerlink" title="数据类型有哪几种"></a>数据类型有哪几种</h2><p>基本数据类型(值类型):number, string, boolean, null, undefined, symbol,bigInt</p>
<p>复杂数据类型(引用数据类型):object(包含 array,function)</p>
<p>Symbol 唯一值, let a =symbol() 类似于唯一性的 ID</p>
<p>BigInt 是一种内置对象,提供了一种方法来表示大于 2 的 53 次方 - 1 的整数,这原本是 Javascript 中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数</p>
<h2 id="Js-语言是什么-特性是什么"><a href="#Js-语言是什么-特性是什么" class="headerlink" title="Js 语言是什么 特性是什么"></a>Js 语言是什么 特性是什么</h2><p>Js 是一门弱类型面向对象的语言,面向对象, 即面向过程的封装</p>
<p>js 中的变量可以用来存储任意的数据类型 对存储的数据类型没有任何要求</p>
<p>js 是一门解释型的语言,只有执行到这个变量的时候，才会最终确定里面到底是什么数据类型</p>
<p>特性:封装性,继承性,多态性(抽象)</p>
<p>弱类型:变量声明的时候不用规定是什么类型的，用的时候它自己根据你赋的值判断。别的编程语言会对变量的类型有严格的限制，之间的转换也有规定</p>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是一个场景,函数 A 内部有一个函数 B,函数 B 访问到函数 A 中的变量,那么就形成了闭包</p>
<p>项目中的应用 ,模块化其实就是闭包的应用,js 中没有模块化的概念,是使用函数/自调用函数来模拟模块</p>
<p>项目中是通过 webpack 等打包工具打包成为函数,模块的导出在另一个模块中导入, 本质上也相对于函数内部嵌套函数,形成了闭包</p>
<h2 id="哪些会造成内存泄漏"><a href="#哪些会造成内存泄漏" class="headerlink" title="哪些会造成内存泄漏"></a>哪些会造成内存泄漏</h2><p>(标记清除,闭包涉及引用计数)</p>
<p>意外的全局变量(使用完后设置为 null), dom 绑定的事件没有解绑，没有清理定时器延时器，闭包等都可以造成内存泄漏</p>
<h2 id="怎样避免内存泄露"><a href="#怎样避免内存泄露" class="headerlink" title="怎样避免内存泄露"></a>怎样避免内存泄露</h2><p>1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收</p>
<p>2）注意程序逻辑，避免“死循环”之类的</p>
<p>3）避免创建过多的对象 原则：不用了的东西要及时归还</p>
<h2 id="圣杯布局的实现方式"><a href="#圣杯布局的实现方式" class="headerlink" title="圣杯布局的实现方式"></a>圣杯布局的实现方式</h2><p>浮动 定位 flex grid(网格布局)</p>
<h2 id="盒子的垂直水平居中方式"><a href="#盒子的垂直水平居中方式" class="headerlink" title="盒子的垂直水平居中方式"></a>盒子的垂直水平居中方式</h2><p>Flex: justify-content:center align-items:center</p>
<p>定位: top50% left50% Transform:translate(-50%,-50%)</p>
<p>网格 grid 父盒子:display:grid 子盒子: justify-self:center; align-self:center</p>
<p>子元素前面加个伪元素: 父元素 text-align 伪元素内容为空 height 为 100% width 为 0,中线对齐,行内块 子盒子设置中心对齐,行内块</p>
<h2 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h2><p>每个对象都会在其内部初始化一个属性，就是 prototype(原型)，当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p>
<p>原型链最上层是 null</p>
<h2 id="深拷贝浅拷贝及其实现方法有哪些"><a href="#深拷贝浅拷贝及其实现方法有哪些" class="headerlink" title="深拷贝浅拷贝及其实现方法有哪些"></a>深拷贝浅拷贝及其实现方法有哪些</h2><p>(假设 A 复制了 B，将 B 的值进行修改，看 A 的值的变化，如果 A 的值发生了改变，说明是浅拷贝，如果 A 的值没有变化就是深拷贝，浅拷贝就是拷贝了内存，当改变了一个指针指向的值时，另外的也发生了变化，而深拷贝是开辟了一个独立的内存，指针指向的值变化时，另一个内存中的值没有变化)</p>
<p>浅拷贝：浅拷贝对于引用类型则只是原先对象引用类型的引用，不是引用自己对象本身。修改会相互影响</p>
<p>深拷贝：深拷贝会对引用类型重新在创新一次(包括值类型)，在新对象做的任何修改都不会影响到源对象本身。</p>
<p>浅拷贝: concat() slice() …展开运算符等</p>
<p>深拷贝: JSON.parse(JSON.stringify()) 递归实现深拷贝</p>
<p>lodash 函数库 lodash.cloneDeep()实现深拷贝</p>
<p>jquery 的 extend 方法实现深拷贝.第一个参数为 true ;$.extend( [deep ], obj1,对象 1,对象 2… )</p>
<p>Object.assign() 展开运算符 当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</p>
<h2 id="获取-dom-的方式"><a href="#获取-dom-的方式" class="headerlink" title="获取 dom 的方式"></a>获取 dom 的方式</h2><p>原生 js 获取方式 document.</p>
<p>React 和 vue 中 ref 方式</p>
<p>Jquery 中$方法</p>
<h2 id="父子组件嵌套的渲染顺序"><a href="#父子组件嵌套的渲染顺序" class="headerlink" title="父子组件嵌套的渲染顺序"></a>父子组件嵌套的渲染顺序</h2><p>父组件前走前三个钩子，再走子组件的 4 个钩子，再走父组件 的 mounted</p>
<h2 id="页面渲染的过程："><a href="#页面渲染的过程：" class="headerlink" title="页面渲染的过程："></a>页面渲染的过程：</h2><p>先解析 html，形成 dom 树，遇到 css，形成 css 树(cssom)，两者结合形成渲染树，再解析 js，发生重绘重排，</p>
<p>重排必定重绘，，怎么减少重排（回流）？</p>
<p>diff 算法可以减少，尽可能避免写行内样式 v-if 和 v-show 也是一种方法 批量修改 DOM 或者样式</p>
<p>onLoad 和$(function(){})区别</p>
<p>onLoad 必须等页面中所有元素加载完后执行, $(function(){})在结构绘制完毕后执行,所以执行时机不同,后者先执行, onLoad只能执行一个,$(function(){})可以存在多个,且都会执行</p>
<h2 id="点击拨打电话"><a href="#点击拨打电话" class="headerlink" title="点击拨打电话"></a>点击拨打电话</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"tel://123"</span>&gt;....&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="element-UI-输入框联想组件"><a href="#element-UI-输入框联想组件" class="headerlink" title="element-UI 输入框联想组件"></a>element-UI 输入框联想组件</h2><p>el-autocomplete</p>
<p>##</p>
<h2 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡"></a>如何阻止冒泡</h2><p>e.stopPropagation()</p>
<h2 id="阻止-a-标签的默认行为"><a href="#阻止-a-标签的默认行为" class="headerlink" title="阻止 a 标签的默认行为"></a>阻止 a 标签的默认行为</h2><p>e.preventDefault()</p>
<p>Javascipt:void(0)</p>
<p>Javascipt:;</p>
<h2 id="on-和-addeventlister-的区别"><a href="#on-和-addeventlister-的区别" class="headerlink" title="on 和 addeventlister 的区别"></a>on 和 addeventlister 的区别</h2><p>On 事件后面的会覆盖前面 只有最后一个事件会生效</p>
<p>addeventlister 可以注册多个事件,并同时生效</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>给父元素注册事件,借用事件冒泡 使得子元素得以注册上想要的事件,数据动态渲染出来的元素无法注册事件,需要通过事件委托给对应的父元素注册事件</p>
<h2 id="浮动和定位的区别"><a href="#浮动和定位的区别" class="headerlink" title="浮动和定位的区别"></a>浮动和定位的区别</h2><p>二维和三维</p>
<h2 id="sort-排序的原理-冒泡排序-其他排序方法"><a href="#sort-排序的原理-冒泡排序-其他排序方法" class="headerlink" title="sort 排序的原理, 冒泡排序 其他排序方法"></a>sort 排序的原理, 冒泡排序 其他排序方法</h2><p>Sort 参数里是一个函数,(a,b)=&gt;return a-b 从小到大排序, return b-a 从大到小</p>
<p>冒泡排序 双重 for 循环,通过比较互换值来实现</p>
<p>其他排序方法</p>
<h2 id="Typeof-和-instanceof-区别"><a href="#Typeof-和-instanceof-区别" class="headerlink" title="Typeof 和 instanceof 区别"></a>Typeof 和 instanceof 区别</h2><p>Typeof 可以用来判断数据的基本类型,除了 null 外的其他原始数据类型都可以正确判断</p>
<p>但是判断对象除了函数可以正确判断,其他返回的都是 object</p>
<p>InstanceOf 是通过原型链的方式判断数据类型,可以正确的判断对象数据类型,但是没有办法准确判断出原始数据类型</p>
<h2 id="valueOf-和-toString"><a href="#valueOf-和-toString" class="headerlink" title=".valueOf()和.toString()"></a>.valueOf()和.toString()</h2><p>.toString() 返回转换成字符串类型的值 针对实例对象返回的是字符串都是[object object] 自定义类型 返回的是[object 自定义类型]</p>
<p>可以通过 constructor 得到返回构造函数源代码</p>
<p>.valueOf( ) 返回值本身类型</p>
<p><code>toString()</code>和<code>String()</code>都是将数据转换为对应的字符串，有如下区别：</p>
<ol>
<li><code>String()</code>可以将任何类型的值转换为字符串，包括<code>undefined和null</code></li>
</ol>
<h2 id="this-指向问题"><a href="#this-指向问题" class="headerlink" title="this 指向问题"></a>this 指向问题</h2><p>箭头函数中 this 指向是外部包裹的第一个函数的 this 指向</p>
<p>Call apply bind 可以改变 this 的指向 第一个参数 call 参数拼接即可 apply 则必须跟一个数组类型的参数 bind 不会立即执行 返回一个待执行的函数</p>
<h2 id="new-干了哪些事"><a href="#new-干了哪些事" class="headerlink" title="new 干了哪些事"></a>new 干了哪些事</h2><p>new 是操作符</p>
<p>1.创建一个空对象</p>
<p>2.将 this 指向了这个空对象</p>
<p>3.执行构造函数里面的代码，给这个对象添加属性和方法</p>
<p>4.返回了这个对象</p>
<h2 id="var-let-const-区别"><a href="#var-let-const-区别" class="headerlink" title="var let const 区别"></a>var let const 区别</h2><p>var 的作用域是函数作用域，在一个函数内利用 var 声明一个变量，则这个变量只在这个函数内有效</p>
<p>存在变量声明提前</p>
<p>let 声明的变量，存在块级作用域</p>
<p>let 不允许在同一作用域内重复声明同一个变量</p>
<p>暂时性死区：在代码块内，使用 let 声明变量之前，该变量都是不可以使用用</p>
<p>const 用来声明常量，一旦声明，其值就不能更改,必须同时初始化,不能先声明，后初始化，这样会报错</p>
<p>与 let 一样。const 声明的常量也只在块级作用域内有效</p>
<p>与 let 一样，必须先声明，后使用</p>
<p>与 let 一样，在同一作用域，const 不能重复声明同一常量</p>
<h2 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h2><p>组合继承,原型继承,构造函数继承</p>
<p>组合继承： 原型继承和构造函数继承组合使用，发挥两者之长的一种继承方式。<br>原型继承: 虽然属性和方法都能继承，但是继承的时候初始化了属性，继承过来的属性的值都是一样的。 构造函数继承: 只能解决了属性继承都是一样的问题，并且值不重复，但是父级类别中的方法不能继承。使用组合继承，属性和方法都能继承</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>函数内部直接或间接调用自己,但必须需要有跳出条件,不然会造成死循环</p>
<h2 id="横向越权与纵向越权"><a href="#横向越权与纵向越权" class="headerlink" title="横向越权与纵向越权"></a>横向越权与纵向越权</h2><p>横向越权：横向越权指的是攻击者尝试访问与他拥有相同权限的用户的资源</p>
<p>纵向越权：纵向越权指的是一个低级别攻击者尝试访问高级别用户的资源</p>
<h2 id="如何防止横向越权漏洞："><a href="#如何防止横向越权漏洞：" class="headerlink" title="如何防止横向越权漏洞："></a>如何防止横向越权漏洞：</h2><p>可通过建立用户和可操作资源的绑定关系，用户对任何资源进行操作时，通过该绑定关系确保该资源是属于该用户所有的。(配合 token 来处理)</p>
<p>对请求中的关键参数进行间接映射，避免使用原始关键参数名，比如使用索引 1 代替 id 值 123 等</p>
<h2 id="如何防止纵向越权漏洞："><a href="#如何防止纵向越权漏洞：" class="headerlink" title="如何防止纵向越权漏洞："></a>如何防止纵向越权漏洞：</h2><p>建议使用基于角色访问控制机制来防止纵向越权攻击，即预先定义不同的权限角色，为每个角色分配不同的权限，每个用户都属于特定的角色，即拥有固定的权限，当用户执行某个动作或产生某种行为时，通过用户所在的角色判定该动作或者行为是否允许。</p>
<p>display none 和 visibility hidden 区别</p>
<p>display none 是彻底消失,不占空间, 会产生重绘回流,</p>
<p>visibility hidden 只是看不到了,但占有相对空间,只重绘不回流</p>
<h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><p>防抖就是高频事件触发,在规定时间内再次触发,则会清除上次,重新计时,原理是清除上次的延时器,重新设置延时器</p>
<p>节流就是高频事件触发,但是规定时间内只会执行一次,原理是判断是否等待执行的延时函数时,则 return</p>
<h2 id="四种定时器"><a href="#四种定时器" class="headerlink" title="四种定时器"></a>四种定时器</h2><p>setTimeout setInterval</p>
<p>setImmediate</p>
<p>在浏览器完全结束当前运行的操作之后立即执行指定的函数</p>
<p>requestAnimationFrame</p>
<p>专门为实现高性能的帧动画而设计的 API，但是不能指定延迟时间，而是根据浏览器的刷新频率而定（帧）</p>
<h2 id="什么是前后端分离及怎么去实施前后端分离"><a href="#什么是前后端分离及怎么去实施前后端分离" class="headerlink" title="什么是前后端分离及怎么去实施前后端分离"></a>什么是前后端分离及怎么去实施前后端分离</h2><p>以前的 JSP 技术就是一个前,后端耦合在一起的技术案例 ,随着 web 化趋势,信息化加深,需求复杂后很难去开发,影响开发效率,所以前端也需要工程化,模块化,组件化的去开发,使用开发中使用前端开发工程式框架,如 vue,react 等,约束性强,可复用组件使用更方便</p>
<p>如何实施: 设计阶段—-需要长远考虑,接口设计非常重要</p>
<p>开发阶段—-还是接口设计 请求方式,数据格式等等…</p>
<p>测试阶段: 前后端独立可测试, 前端 页面,跳转,展示,传参,后端:数据接口的提供,数据根式,权限等</p>
<p>部署阶段: 前后端单独部署,各自发版本互不影响</p>
<h2 id="数组拍平-数组降维"><a href="#数组拍平-数组降维" class="headerlink" title="数组拍平(数组降维)"></a>数组拍平(数组降维)</h2><p>最简单:flat(要拉平的层数)，flatMap(处理函数)对数组成员都执行一次函数,然后调用 flat()方法,只能展开一层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">递归</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">product</span>(<span class="params"></span>) </span>&#123;   该方法可以将push等方法换成展开运算符</span><br><span class="line"> <span class="keyword">var</span> newarr = [];</span><br><span class="line"> <span class="comment">///2、并且返回一个函数,函数参数为要拍平的数组</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 3、循环数组，判断每一项,不为输的话将其塞入newarr</span></span><br><span class="line">  <span class="comment">// 若为数组,递归调用 faltten,并将结果与newarr合并</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">of</span> arr) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(t)) &#123;</span><br><span class="line">    newarr.push(t);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newarr.concat(flatten(t))</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newarr</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tostring()方法</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr.toString().split(<span class="string">','</span>).map(<span class="function"><span class="params">val</span> =&gt;</span> +val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reduce方法</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(value) ? [...pre, ...flat(value)] : [...pre, value]</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Canvas-和-svg-区别"><a href="#Canvas-和-svg-区别" class="headerlink" title="Canvas 和 svg 区别"></a>Canvas 和 svg 区别</h2><p>canvas 是 html5 提供的新元素<canvas> ,</p>
<p>SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。</p>
<p>Canvas 是一个画布,但 svg 图形是有 dom 结构的, canvas 图形是没有 dom 结构的 给 canvas 绑定事件,委托事件 或者通过记录图片所在 canvas 的坐标来判断事件作用于哪个图片中</p>
<h2 id="预防-xss-攻击"><a href="#预防-xss-攻击" class="headerlink" title="预防 xss 攻击"></a>预防 xss 攻击</h2><p>xss 跨站脚本攻击</p>
<p>对输入信息进行转义处理,支付方面涉及更多,保证信息的安全性</p>
<h2 id="防御-CSRF-攻击"><a href="#防御-CSRF-攻击" class="headerlink" title="防御 CSRF 攻击"></a>防御 CSRF 攻击</h2><p>跨站请求攻击</p>
<p>​ 目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段(记录了该 HTTP 请求的来源地址 )；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p>
<h2 id="箭头函数没有自己的-this-和-arguments"><a href="#箭头函数没有自己的-this-和-arguments" class="headerlink" title="箭头函数没有自己的 this 和 arguments"></a>箭头函数没有自己的 this 和 arguments</h2><p>如果这 2 个变量可以打印出来值，那么他们一定是来自父级作用域的</p>
<h2 id="flex-的三个属性"><a href="#flex-的三个属性" class="headerlink" title="flex 的三个属性"></a>flex 的三个属性</h2><p>flex-direction(row,column…) flex-wrap justify-content align-items align-content</p>
<p>（1）flex-grow；指的是相对于其他的子元素的扩展比率；默认值为 0；数字</p>
<p>（2）flex-basis；指的是子元素的具体长度；可以为长度（rem，px，em）也可以为百分比；</p>
<p>（3）flex-shink；指的是相对于其他元素的收缩比率；默认值为 0；数字</p>
<h2 id="ES6-map-和-set"><a href="#ES6-map-和-set" class="headerlink" title="ES6 map 和 set"></a>ES6 map 和 set</h2><p>new set() .add() 可以往里面添加数据 set 对象保证里面的元素是独特的 不重复的 , .delete()会返回 true 或者 false 表示是否删除</p>
<p>.has() 表示里面是否有什么元素 返回 true 和 fasle, .size 判断里面有多少个元素 , .forEach() 遍历</p>
<p>new map() .set(‘name’,111) 添加数据 , .get(‘name’) 获取 , .size 判断里面有多少个元素 .has() 表示里面是否有什么元素 返回 true 和 fasle,</p>
<p>注意点 map 里面 ,set 如果已有的 会覆盖原来的值 .delete .forEach</p>
<h2 id="For-in-循环和-for-of-循环的区别"><a href="#For-in-循环和-for-of-循环的区别" class="headerlink" title="For in 循环和 for of 循环的区别"></a>For in 循环和 for of 循环的区别</h2><p>For in 主要用来遍历对象,遍历时不仅可以读取自身的属性,还能沿原型链遍历对象的原型属性 (hasOwnProperty()方法可以判断一个属性是不是自身上的)</p>
<p>For of es6 引入,语法和 for in 相同,但没有他的缺点,可以与 break,return 配合,随时跳出循环</p>
<p>For in 获取的是键名,for of 获取的是键值对中的值</p>
<h2 id="Object-entries-和-reduce-方法"><a href="#Object-entries-和-reduce-方法" class="headerlink" title="Object.entries() 和 reduce()方法"></a>Object.entries() 和 reduce()方法</h2><p>Object.entries(obj) 将数组或对象返回一个自身可枚举属性的键值对数组集合 ,该集合包含了数组的键值对,数组使用方法时,键为索引</p>
<p>数组的 reduce()方法 是一个累加器 参数 1 是一个函数 参数有: 1 累加器的合(用于存放每次操作需要存放变量的地方) ,2 循环当前的值, 参数 2 初始值</p>
<p>reduce(function,初始值)</p>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign 是 ES6 新添加的接口，主要的用途是用来合并多个 JavaScript 的对象。</p>
<p>Object.assign()接口可以接收多个参数，第一个参数是目标对象，后面的都是源对象，assign 方法将多个原对象的属性和方法都合并到了目标对象上面，如果在这个过程中出现同名的属性（方法），后合并的属性（方法）会覆盖之前的同名属性（方法）。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>Cors 前端需要 要么* 前端不需要任何配置 请求配置 withCreadential：true,主要为后端配置</p>
<p>JsonP 原理是 script 标签获取数据不受同源策略限制</p>
<p>反向代理 服务器和服务器之间不存在跨域,借用中间代理服务器 解决跨域问题</p>
<h2 id="反向代理-解决跨域"><a href="#反向代理-解决跨域" class="headerlink" title="反向代理 (解决跨域)"></a>反向代理 (解决跨域)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        ...,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123; <span class="comment">//这里最好有一个 /</span></span><br><span class="line">                target: <span class="string">'http://106.ihuyi.com'</span>,         <span class="comment">// 服务器端接口地址</span></span><br><span class="line">                ws: <span class="literal">true</span>, <span class="comment">//如果要代理 websockets，配置这个参数</span></span><br><span class="line">                <span class="comment">// 如果是https接口，需要配置这个参数</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>,  <span class="comment">//是否跨域</span></span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">        			<span class="comment">//把中间拼接不需要的替换成空</span></span><br><span class="line">                    <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue-lazyload-图片懒加载"><a href="#vue-lazyload-图片懒加载" class="headerlink" title="vue-lazyload 图片懒加载"></a>vue-lazyload 图片懒加载</h2><p>多一个指令 v-lazy</p>
<h2 id="浏览器兼容问题"><a href="#浏览器兼容问题" class="headerlink" title="浏览器兼容问题"></a>浏览器兼容问题</h2><p>H5 兼容问题</p>
<p>html5shiv 包 注释法引入</p>
<p>css3 兼容问题</p>
<p>不同浏览器 css 样式初始化 浏览器私有属性:加浏览器内核前缀 <strong>CSS hack</strong> (针对不同的浏览器或不同版本写特定的 CSS 样式 )</p>
<p><strong>Autoprefixer</strong>是一款自动管理浏览器前缀的插件，它可以解析 CSS 文件并且添加浏览器前缀到 CSS 内容里。</p>
<p>vue 项目不支持 ie8 及以下浏览器,因为 ie8 及以下浏览器不支持数据劫持 API</p>
<p>低版本浏览器 ie6 7 8 引入了一个 htc 文件 ie-css3.htc 还需要在用到的 css3 的样式里面补一句 behavior:url(ie-css3.htc)</p>
<p>js 兼容问题</p>
<p>vue 项目中,通过设置 babel-loader 转码器来解决旧版本浏览器不识别 es6 新语法的问题,同时部分新语法不能完全转换,还需要设置 babel-plofilly,下载,引入即可</p>
<h2 id="提高页面的渲染性能？"><a href="#提高页面的渲染性能？" class="headerlink" title="提高页面的渲染性能？"></a>提高页面的渲染性能？</h2><p>减少 dom 操作，加速服务器，cdn 优化，缓存，懒加载，分页，预加载，</p>
<p>\1. 减少服务器请求次数 精灵图等</p>
<p>\2. 减少请求数据的量</p>
<p>3.插件之类的按需加载</p>
<h2 id="CDN-优化问题"><a href="#CDN-优化问题" class="headerlink" title="CDN 优化问题"></a>CDN 优化问题</h2><p>内容分发网络</p>
<p>CDN 是性能优化的一种方式,CDN 通过 CDN 负载均衡设备选择一台最合适的 CDN 缓存服务器地址发送给用户,比如根据所需资源,离用户 IP 较近,缓存服务器负载较小等判断条件</p>
<h2 id="http-和-https-协议"><a href="#http-和-https-协议" class="headerlink" title="http 和 https 协议"></a>http 和 https 协议</h2><p>http 超文本传输协议,,是互联网应用最广泛的的一种网络协议, 是无状态无记忆的,而且是明文方式传输的</p>
<p>浏览器和服务器通过 TCP 建立连接,请求的格式一般包括统一资源符(url),协议版本号,MIME 信息等</p>
<p>https 是以安全为目标的 http 通道,http 的安全基础是 SSL,SSL 结合 http,SSL 可分为两层,SSL 记录协议和 SSL 握手协议,前者提供数据封装,压缩加密的支持,后者提供通讯双方的身份认证,协商加密算法等</p>
<p>区别:</p>
<p>2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</p>
<p>3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
<p>4、http 的连接很简单，是无状态的。Https 协议是由 SSL+Http 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</p>
<h2 id="http1-和-http2-区别"><a href="#http1-和-http2-区别" class="headerlink" title="http1 和 http2 区别"></a>http1 和 http2 区别</h2><p>http2 使用二进制传输,http1 使用明文传输</p>
<p>http1 TCP 连接数量的限制,线头阻塞问题, header 内容较多</p>
<p>http2 支持多路复用 http2 头部压缩 http2 支持服务器推送</p>
<h2 id="websocket-协议"><a href="#websocket-协议" class="headerlink" title="websocket 协议"></a>websocket 协议</h2><p>websocket 协议是基于 TCP 的一种新的网络协议,它实现了浏览器和服务器全双工通信,允许服务器主动发送信息给客户端</p>
<p>在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>是一种传输控制网络协议,也叫网络通讯协议 , 建立一次 TCP 连接需要经历三次握手 syn 数据包– syn-ack—ack</p>
<p>syn 请求 ack 响应 fin 请求断开</p>
<h2 id="RESTful-接口规范"><a href="#RESTful-接口规范" class="headerlink" title="RESTful 接口规范"></a>RESTful 接口规范</h2><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">RESTful</a>  是目前最流行的 API 设计规范，用于 Web 数据接口的设计出的接口就称之为 RESTful 接口</p>
<p>请求层规范</p>
<p>​ 请求 API 的 URL 表示用来定位资源； 所有资源都有一个资源标志符,对资源的操作不会改变标志符</p>
<p>​ 请求的 METHOD 表示对这个资源进行的操作； 所有的操作都是无状态的</p>
<p>REST 风格的接口地址，表示的可能是单个资源，也可能是资源的集合；当我们需要访问资源集合时，设计良好的接口应当接受参数，允许只返回满足某些特定条件的资源列表。</p>
<p>涉及到 域名 资源路径 方法(get,post,put,patch(部分更新),delete) 过滤(及参数传递) 状态码, 成功数据的返回形式 等内容</p>
<p>状态码 2XX 表示成功 3XX 重定向 4XX 客户端错误 5XX 服务器错误</p>
<h2 id="http-协议相关内容-地址栏发生改变发生了什么"><a href="#http-协议相关内容-地址栏发生改变发生了什么" class="headerlink" title="http 协议相关内容-地址栏发生改变发生了什么"></a>http 协议相关内容-地址栏发生改变发生了什么</h2><p>http 是超文本传输协议,当地址栏发生改变,先判断 url 是否合法,然后判断缓存是否存在,如果没有在发生 DNS 解析(把域名指向网站空间 IP ),读取后台的 IP 地址,然后通过 IP 地址找到后台建立 TCP 连接,经历三次握手,建立连接,传送数据,(如果文件格式等资源过大,是分段发送的,最后会重新合并解析)四次挥手确认关闭,断开链接,最后拿到数据,渲染页面</p>
<p>TCP 不存在连接的概念，只存在请求和响应，请求和响应都是数据包</p>
<p>TCP 的状态标识</p>
<p>​ SYN 表示建立连接，</p>
<p>​ FIN 表示关闭连接，</p>
<p>​ ACK 表示响应，</p>
<p>​ PSH 表示有 DATA 数据传输，</p>
<p>​ RST 表示连接重置。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手: 呼叫服务器听到请回答…..</p>
<p>​ 1.客户端发送请求建立连接，请求报文段。</p>
<p>第二次握手: 好的收到,你听到了吗</p>
<p>​ 服务器收到请求，发送同意并请求与客户端建立连接。</p>
<p>第三次握手: 听到了,我们可以说话了…</p>
<p>​ 客户端收到请求，发送同意与服务器建立连接。</p>
<p>三次握手的作用:防止已失效的连接请求又发送到了服务器</p>
<p><strong>四次挥手的步骤</strong></p>
<blockquote>
<p>1.第一次挥手：客户端发送断开请求</p>
</blockquote>
<blockquote>
<p>2.第二次挥手：服务器收到断开请求，发送同意断开连接的请求</p>
</blockquote>
<blockquote>
<p>3.第三次挥手：服务器发送请求断开连接</p>
</blockquote>
<blockquote>
<p>4.第四次挥手：客户端收到，发送同意断开连接</p>
</blockquote>
<h2 id="http-缓存和浏览器缓存"><a href="#http-缓存和浏览器缓存" class="headerlink" title="http 缓存和浏览器缓存"></a>http 缓存和浏览器缓存</h2><p>浏览器缓存包括 本地存储 cookie WebStorage indexDB 等 默认缓存</p>
<p>http 缓存</p>
<p>强制缓存 在缓存数据未失效的情况下，可以直接使用缓存数据， 缓存规则的信息包含在响应头里面,其中服务器返回的到期时间,即在下一次请求时,时间小于到期时间的话,直接使用缓存 HTTP 1.1 的版本，使用<strong>Cache-Control</strong></p>
<p>协商缓存</p>
<p>第一次请求时,服务器会将缓存标识与数据一起发送给客户端, 再次请求数据时,客户端将标识发送给服务器,服务器根据缓存标识进行判断, 标识是在请求头和响应头之间传递</p>
<p>将缓存信息中的 Etag(标识)和 Last-Modified(资源的最后修改时间)通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。</p>
<p>缓存的作用 减少消耗,降低服务器压力,减少网络延时,提升页面渲染速度</p>
<h2 id="服务端渲染-SSR-和客户端渲染的区别"><a href="#服务端渲染-SSR-和客户端渲染的区别" class="headerlink" title="服务端渲染 SSR 和客户端渲染的区别"></a>服务端渲染 SSR 和客户端渲染的区别</h2><p>服务器端渲染</p>
<p>服务端在后台将 html 结构渲染完成后返回给前端完整的 HTML 文件,浏览器拿到 html 文件后就可以直接解析展示了</p>
<p>优点: 前端耗时少,有利于 SEO,无需占用客户端资源,后端生成静态化文件,可以减少数据库的查询时间,对于数据变化不大的页面非常高效</p>
<p>缺点: 不利于前后端分离,开发效率低,占用服务器资源</p>
<p>客户端渲染</p>
<p>后端提供不完整的 html 页面,提供一些 API 使得前端可以获取 json 数据,,拿到数据后在前端进行 html 页面的拼接,然后解析展示</p>
<p>优点: 前后端分离, 体验更好,做成 SPA,尤其移动端更接近原生 APP</p>
<p>缺点:不利于 SEO,前端响应较慢</p>
<h2 id="图片过多时优化"><a href="#图片过多时优化" class="headerlink" title="图片过多时优化"></a>图片过多时优化</h2><p>1.压缩图片</p>
<p>2.做成雪碧图</p>
<p>3.将图片服务和应用服务分类, 即图片服务器是专门为图片读写操作优化的独立服务器,运行网站的服务器称为应用服务器</p>
<p>4.图片懒加载</p>
<p>5.将图片压缩成 base64,随 html 或者 css 一起下载到浏览器,不需要额外的请求,这样就节约了请求. webpack 中可以配置多少 kb 以下可以转 base64,如果文件太大 转 base64 ,体积会变大 30%左右,得不偿失</p>
<h2 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h2><p>vue 正常打包之后一些图片文件很大，使打包体积很大，通过 image-webpack-loader 插件可将大的图片进行压缩从而缩小打包体积</p>
<p>下载 image-webpack-loader vue.config.js 配置</p>
<h2 id="图片分块上传"><a href="#图片分块上传" class="headerlink" title="图片分块上传"></a>图片分块上传</h2><p>不一定正确(两个方法需要后端配合端口函数处理才可以)</p>
<p>设置一个大小界限,通过图片大小除以界限算出次数,通过创建 new FormData() 创建 formData 对象来异步上传,for 循环添加再 ajax 上传</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shardCount; ++i) &#123;</span><br><span class="line">      <span class="comment">//计算每一片的起始与结束位置</span></span><br><span class="line">      <span class="keyword">var</span> start = i * shardSize,</span><br><span class="line">          end = <span class="built_in">Math</span>.min(size, start + shardSize);</span><br><span class="line">      <span class="comment">//构造一个表单，FormData是HTML5新增的</span></span><br><span class="line">      <span class="keyword">var</span> form = <span class="keyword">new</span> FormData();</span><br><span class="line">      form.append(<span class="string">"data"</span>, file.slice(start, end));  <span class="comment">//slice方法用于切出文件的一部分</span></span><br><span class="line">      form.append(<span class="string">"name"</span>, name);</span><br><span class="line">      form.append(<span class="string">"total"</span>, shardCount);  <span class="comment">//总片数</span></span><br><span class="line">      form.append(<span class="string">"index"</span>, i + <span class="number">1</span>);        <span class="comment">//当前是第几片</span></span><br><span class="line">        <span class="comment">//Ajax提交</span></span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">          url: <span class="string">"../Test/Upload"</span>,</span><br><span class="line">          type: <span class="string">"POST"</span>,</span><br><span class="line">          data: form,</span><br><span class="line">          <span class="keyword">async</span>: <span class="literal">true</span>,        <span class="comment">//异步</span></span><br><span class="line">          processData: <span class="literal">false</span>,  <span class="comment">//jquery不要对form进行处理</span></span><br><span class="line">          contentType: <span class="literal">false</span>,  <span class="comment">//指定为false才能形成正确的Content-Type</span></span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="comment">//成功后的事件</span></span><br><span class="line">              succeed++;</span><br><span class="line">              <span class="keyword">if</span> (succeed == shardCount)</span><br><span class="line">              &#123;</span><br><span class="line">                  Merge();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Merge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          $.ajax(&#123;</span><br><span class="line">              url: <span class="string">"../Test/Merge"</span>,</span><br><span class="line">              type: <span class="string">"get"</span>,</span><br><span class="line">              success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FormData 对象的使用：</span><br><span class="line"><span class="number">1.</span>用一些键值对来模拟一系列表单控件：即把form中所有表单元素的name与value组装成</span><br><span class="line">一个queryString</span><br><span class="line"><span class="number">2.</span> 异步上传二进制文件。</span><br></pre></td></tr></table></figure>

<h2 id="开启-Gzip-压缩"><a href="#开启-Gzip-压缩" class="headerlink" title="开启 Gzip 压缩"></a>开启 Gzip 压缩</h2><p>下载 compression-webpack-plugin vue.config.js 配置</p>
<p>cnpm install compression-webpack-plugin –save-dev</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">          algorithm: <span class="string">'gzip'</span>,</span><br><span class="line">          test: <span class="regexp">/\.(js|css)$/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">          threshold: <span class="number">10240</span>, <span class="comment">// 对超过10k的数据压缩</span></span><br><span class="line">          deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 不删除源文件</span></span><br><span class="line">          minRatio: <span class="number">0.8</span> <span class="comment">// 压缩比</span></span><br><span class="line">        &#125;)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="ajax-和-axios-怎么撤回"><a href="#ajax-和-axios-怎么撤回" class="headerlink" title="ajax 和 axios 怎么撤回"></a>ajax 和 axios 怎么撤回</h2><p>原生 ajax 通过 xhr 对象调用 .abort() jquery 中同样可以调用 将$ajax 赋值给一个变量 然后 变量 .abort()</p>
<p>axios</p>
<p>axios.提供了 CancelToken()方法取消请求</p>
<p>先引用 axios.CancelToken，然后调用 source()方法，会产生一个 token 和 cancel 调用 cancel 即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行source()得到的是一个包含了cancelToken对象和一个取消函数cancel()的对象</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"><span class="comment">// 执行取消请求（message 参数是可选的）</span></span><br><span class="line">source.cancel(<span class="string">'Operation canceled by the user.'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ajax-设置-token"><a href="#ajax-设置-token" class="headerlink" title="ajax 设置 token"></a>ajax 设置 token</h2><p>在 headers 请求头中设置 token</p>
<p>使用 beforeSend 方法设置请求头,reqest.setRequestHeader(‘userToken’,token)</p>
<h2 id="异步操作的常见语法"><a href="#异步操作的常见语法" class="headerlink" title="异步操作的常见语法"></a>异步操作的常见语法</h2><p>1.事件监听 2.回调 如 ajax 入口函数都是回调 3promise 对象</p>
<p>nodeJS 的招牌是无阻塞高并发,实现的关键点是异步</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>promise 是一种异步编程的解决方案,是想以同步代码书写的方式书写异步的代码,解决回调地狱的问题</p>
<p>promise 是一个对象,使用 new 的方式创建,接受一个执行函数作为参数,其中有 resolve 和 reject 两个函数参数,promise 有三个状态,pending fullfilled rejected 改变状态后 promise 会状态凝固 通过内部 resolve 或者 reject 调用 执行 then 里面的第一个或者第二个回调</p>
<p>promise.then 方法每次调用 都返回一个新的 promise 对象 所以可以链式写法</p>
<p>当 reject 后,一定会进入 then 中的第二个回调,如果 then 中没有第二个,则会进入 catch</p>
<p>当 resolve 后,一定会进入 then 的第一个回调,肯定不会进入 catch</p>
<p>诸如网络异常等情况,会直接进入 catch,不会进入 then 的第二个回调</p>
<h2 id="axios-和-ajax-区别-优缺点"><a href="#axios-和-ajax-区别-优缺点" class="headerlink" title="axios 和 ajax 区别 优缺点"></a>axios 和 ajax 区别 优缺点</h2><p>ajax 核心是 XMLHttpRequest,多个请求之间有先后关系会出现回调地狱 jquery 中的 ajax 还增添了 jsonp 的支持</p>
<p>缺点: 如果要使用 ajax 要引入 jquery ,得不偿失, XHR 本身架构不清晰,针对 MVC 编程不符合 MVVM,配置调用方式比较混乱,基于事件的异步模型不友好</p>
<p>axios 是基于 Promise 的一个 Http 库,本身也是针对原生的封装,只不过是 Promise 实现版本</p>
<p>优点: 支持 promiseAPI 客户端防止 CSRF ,拦截请求响应, 从浏览器中创建 XMLHttpRequest,从 nodeJS 创建 http 请求,自动转 JSON 数据</p>
<p>拓展:fetch 是一个低层次的 API,只会对网络报错,不支持 abort() 没有办法监听请求的进度</p>
<p>vue-resource 早期 vue 使用, 提供一系列的 API, get(url,[data],[success],[options]) 也是调用.then()的来处理响应结果</p>
<p>this.$http.get(url,[options]).then(…)</p>
<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>async 顾名思义是“异步”的意思，async 用于声明一个函数是异步的。而 await 从字面意思上是“等待”的意思，就是用于等待异步完成。并且 await 只能在 async 函数中使用 直到返回成功的结果</p>
<p>通常 async、await 都是跟随 Promise 一起使用的。因为 async 返回的都是一个 Promise 对象同时 async 适用于任何类型的函数上。这样 await 得到的就是一个 Promise 对象(如果不是 Promise 对象的话那 async 返回的是什么 就是什么)；</p>
<p>await 得到 Promise 对象之后就等待 Promise 接下来的 resolve 或者 reject。</p>
<h2 id="多个-async-和-await-会造成加载慢的问题"><a href="#多个-async-和-await-会造成加载慢的问题" class="headerlink" title="多个 async 和 await 会造成加载慢的问题"></a>多个 async 和 await 会造成加载慢的问题</h2><p>​ 创建一个数组，然后将所有的 promise 放进数组中。然后使用<code>Promise.all()</code>，我们就可以并行等待所有的 promise 处理。</p>
<p>promise.all 需慎用，否则会造成其中一个请求失败而导致程序阻塞的风险，解决方法：封装的 async/await 中无论 success/fail 都是用 resolve 返回 data，由返回值进行判断而非使用会导致阻塞的 reject</p>
<h2 id="scss-和-less-区别-优缺点"><a href="#scss-和-less-区别-优缺点" class="headerlink" title="scss 和 less 区别,优缺点"></a>scss 和 less 区别,优缺点</h2><p>编译的环境不一样,scss 是在服务端处理的,less 是开发环境使用,可以编译成 css 文件</p>
<p>变量符不一样 前者$ 后者@ scss 支持条件语句 for{} if{}等 less 不支持</p>
<p>less 可以设置变量, 可以嵌套 缺点 编译出来的 css 文件比直接写大一点</p>
<p>scss 更简洁,适应性更强,可读性更佳, 缺点是文件体积和复杂度不可控,调试难度增加</p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack 是一个模块打包器,可以递归打包项目中的所有模块,最终只生成几个打包后的文件</p>
<p>bundle 是 webpack 打包出来的文件,chunk 是指 webpack 在进行模块的依赖分析的时候，代码分割出来的代码块。module 是开发中的单个模块。</p>
<p>webpack 构建流程是 初始化参数—开始编译—确定入口—编译模块—完成模块编译—输出资源—-输出完成</p>
<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack 服务器设置 比如自动打开浏览器,设置端口号等 devServer:{…}</p>
<p>webpack-dev-server 使用内存来存储 webpack 开发环境下的打包文件，并且可以使用模块热更新，他比传统的 http 服务对开发更加简单高效。</p>
<p>模块热更新是 webpack 的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器</p>
<h2 id="webpack-和-gulp-的区别"><a href="#webpack-和-gulp-的区别" class="headerlink" title="webpack 和 gulp 的区别"></a>webpack 和 gulp 的区别</h2><p>都是前端构建工具, 模块打包器,gulp 早期比较流行</p>
<p>gulp 是基于任务的, 类似 jquery,找到一个文件,对其做一系列链式操作,整条链式操作构成了一个任务,多个任务构成了整个 web 的构建流程</p>
<p>webpack 是基于入口的,会自动递归解析入口所需要的所有资源文件,然后用不同的 loader 去处理,plugin 去扩展 webpack 的功能</p>
<h2 id="loader-和-plugin-区别"><a href="#loader-和-plugin-区别" class="headerlink" title="loader 和 plugin 区别"></a>loader 和 plugin 区别</h2><p>loader 是加载器,让 webpack 拥有加载和解析非 javascript 文件的能力,</p>
<p>plugin 是插件,可以扩展 webpack 的功能,让 webpack 更加灵活</p>
<h2 id="env-文件配置"><a href="#env-文件配置" class="headerlink" title=".env 文件配置"></a>.env 文件配置</h2><p>作用是配置一些全局变量等 如 url 这样就可以分别使用测试的服务器地址和生产的服务器地址了</p>
<p>.env.development 开发环境</p>
<p>.env.production 生成环境</p>
<p>不同环境运行的时候,process.env. XXX 可以根据情况自己调用相应文件中的变量</p>
<h2 id="dependencies-和-devDependencies-区别"><a href="#dependencies-和-devDependencies-区别" class="headerlink" title="dependencies 和 devDependencies 区别"></a>dependencies 和 devDependencies 区别</h2><ul>
<li><code>devDependencies</code>用于本地环境开发时候。</li>
</ul>
<p>开发环境依赖的模块,生成环境不会被打入包内</p>
<ul>
<li><code>dependencies</code>用户发布环境</li>
</ul>
<p>生产环境依赖的模块,生产环境会打入包内</p>
<p>–save 和 -S 是一样 3 –save-dev 和 -D 是一样的</p>
<h2 id="Vue-cli-打包后白屏-资源路径为绝对路径-需要将所有资源改为相对路径"><a href="#Vue-cli-打包后白屏-资源路径为绝对路径-需要将所有资源改为相对路径" class="headerlink" title="Vue-cli 打包后白屏,资源路径为绝对路径,需要将所有资源改为相对路径"></a>Vue-cli 打包后白屏,资源路径为绝对路径,需要将所有资源改为相对路径</h2><p>(vue-cli3 之后)Vue.config.js 中修改配置代码: publicPath: ‘./‘</p>
<h2 id="Vue-项目打包成移动端-APP"><a href="#Vue-项目打包成移动端-APP" class="headerlink" title="Vue 项目打包成移动端 APP"></a>Vue 项目打包成移动端 APP</h2><p>Hbuilder 工具</p>
<p>百度教程,不需要去记:(首先打包 vue 到 dist 目录</p>
<p>然后再 Hbuilder 中打开 dist 目录</p>
<p>然后将 dist 包含的 web 项目 转换为 移动 APP 项目</p>
<p>前几步配置完成后，就可以在手机上进行真机调试了</p>
<p>真机测试没有问题，就可以进行下一步—》打包 apk 了</p>
<p>最后将 apk 安装包安装到手机上就可以正常使用了)</p>
<h2 id="为什么通常在发送数据埋点请求时使用-gif-图片"><a href="#为什么通常在发送数据埋点请求时使用-gif-图片" class="headerlink" title="为什么通常在发送数据埋点请求时使用 gif 图片"></a>为什么通常在发送数据埋点请求时使用 gif 图片</h2><p>​ 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）</p>
<p>​ 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据</p>
<p>​ 跨域友好</p>
<p>​ 执行过程无阻塞</p>
<p>​ 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好</p>
<p>​ GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）</p>
<h2 id="Vue-的原理"><a href="#Vue-的原理" class="headerlink" title="Vue 的原理"></a>Vue 的原理</h2><p>1、建立虚拟 DOM Tree<br>2、通过 Object.defineProperty()进行数据变化拦截；<br>3、截取到的数据变化，通过发布者-订阅者模式，触发 Watcher，从而改变虚拟 DOM 中的具体数据；<br>4、通过改变虚拟 DOM 元素值，从而改变最后渲染 dom 树的值，完成双向绑定</p>
<p>完成数据的双向绑定在于 Object.defineProperty()</p>
<h2 id="Vue-的双向数据绑定原理"><a href="#Vue-的双向数据绑定原理" class="headerlink" title="Vue 的双向数据绑定原理"></a>Vue 的双向数据绑定原理</h2><p>采用数据劫持结合订阅-发布者模式,通过 Object.definePropetry()来劫持 data 中各个属性的 get 和 set,在数据变动时,发布消息给订阅者,触发响应的监听回调</p>
<p>(1) 实现一个数据监听器 Observer,能够对数据对象的所有属性进行监视,如有变动可拿到最新值并通知订阅者</p>
<p>(2) 实现一个指令解析器 Compile,对每个元素节点的指令进行扫描和解析,根据指令模板替换数据,以及绑定相应的更新函数</p>
<p>(3) 实现一个 Watcher,作为连接 Observer 和 Compile 的桥梁,能够订阅并收到每个属性变动的通知,指令执行绑定的相应回调函数,从而更新视图</p>
<p>订阅-发布者模式(subscribe/publish,观察者模式) 总结起来就是</p>
<p>1.将注册的函数收集起来,<strong>（订阅)</strong> 2.在触发时，逐个触发  <strong>（发布)</strong> 3.还可以根据 key 来删除某个监听函数。</p>
<h2 id="观察者模式-Observer-和发布-Publish-订阅者-Subscribe-区别"><a href="#观察者模式-Observer-和发布-Publish-订阅者-Subscribe-区别" class="headerlink" title="观察者模式(Observer)和发布(Publish)/订阅者(Subscribe)区别"></a>观察者模式(Observer)和发布(Publish)/订阅者(Subscribe)区别</h2><p>观察者和目标都是基类,观察者提供更新的接口,具体观察者和具体目标继承各自的基类,然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。</p>
<p>发布订阅者 订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心（顺带上下文），由调度中心统一调度订阅者注册到调度中心的处理代码。</p>
<p><strong>总结</strong></p>
<p>虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者、具体目标可认为是发布者），但是观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会。</p>
<p>两种模式都可以用于松散耦合，改进代码管理和潜在的复用。</p>
<h2 id="Vue-的路由实现原理"><a href="#Vue-的路由实现原理" class="headerlink" title="Vue 的路由实现原理"></a>Vue 的路由实现原理</h2><p>更新视图但不重新请求页面，是前端路由原理的核心之一,通过两种方式 hash 和 history,</p>
<p>hash 即地址栏 URL 中的 # 符号,它的特点在于：hash 不被包括在 HTTP 请求中；仅 hash 符号之前的内容会被包含在请求中,因此即使没有做到对路由的全覆盖，也不会返回 404 错误和重加载页面。</p>
<p>history history 采用 HTML5 的新特性提供的两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及 popState 事件的监听到状态变更,它们提供了对历史记录进行修改的功能。</p>
<p>pushState 方法只是向历史栈中写入数据 ,不会触发页面刷新，只是导致 history 对象发生变化，地址栏会有反应,只有当触发前进后退等事件（back()和 forward()等）时浏览器才会刷新</p>
<p>replaceState(stateObj, title, url) 和 pushState 的区别就在于它不是写入而是替换修改浏览历史中当前纪录</p>
<p>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致,所以需要后台配置支持,需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面</p>
<h2 id="Vue-有什么缺点"><a href="#Vue-有什么缺点" class="headerlink" title="Vue 有什么缺点"></a>Vue 有什么缺点</h2><p>vue 更适合开发小型项目，路由短，页面逻辑不复杂，处理数据少。而 react 更适合写大型项目，尤其是长期维护的那种因为 react 可定制的程度更高。</p>
<p>仔细分析，vue 会封装出很多高级的 api，在项目复杂的情况下，你受到的约束也越大，可定制化也越低，相比之下，react 就更加随心所欲。</p>
<p>高级 api 很多情况下会用统一的通用设置把不常见的 api 的参数给屏蔽掉，以减少我们的开发成本，vue 在小项目中你能明显感觉到这种优势。</p>
<p>但是随着项目体量变大，react 你就会发现他可以让你更加接近原生的去写，更加可定制，项目体量越大，你在项目中个人定制化，抽出的组件越多，你就越能感觉到便捷，还有那个数据绑定，你会发现 react 更可理解最追踪。</p>
<p>· 基于对象配置文件的组件写法，背后做了一大堆重挂 this 之类的魔法操作，对编辑器的语义理解很不友好，组件内自动重构（比如 vscode 的 f2/f12）基本就残废了（所以 vue3 会有新的 class 语法）</p>
<p>· 官方配件（router/vuex)和社区都流行直接往 Vue.prototype 上挂东西，this.$router this.$store 等等，照样不利于编辑器的语义理解，大项目里面很难简单地做项目内跨文件自动搜索引用/自动重构</p>
<p>· vuex 的 commit/dispatch 的魔法字符串语法，照样对编辑器语义理解不友好</p>
<h2 id="vue3-0-新特性"><a href="#vue3-0-新特性" class="headerlink" title="vue3.0 新特性"></a>vue3.0 新特性</h2><p>1.vue 压缩后体积更小,比以前的 20Kb 小了一半</p>
<p>2.使用 Proxy 取代 Object.defineProperty 将直接操作对象的属性,通过在对象目标加上一层拦截,变成对整个对象的操作</p>
<p>3.虚拟 dom 重构, 3.0 中将 vdom 更新性能由与模板整体大小相关提升到与动态内容的数量相关</p>
<p>4.一些编译方面的优化</p>
<h2 id="Vue-的生命周期函数"><a href="#Vue-的生命周期函数" class="headerlink" title="Vue 的生命周期函数"></a>Vue 的生命周期函数</h2><p>数据挂载前后 beforeCreate created(初始化数据)</p>
<p>视图渲染前后 beforeMount mounted(可以进行 dom 操作)</p>
<p>数据更新渲染前后 beforeUpdate updated</p>
<p>实例销毁 beforeDestroy destoryed</p>
<h2 id="vue-路由组件懒加载"><a href="#vue-路由组件懒加载" class="headerlink" title="vue 路由组件懒加载"></a>vue 路由组件懒加载</h2><p>如果路由组件代码多的情况下,可以将 app.js 中 导入模块 import xxx from ‘…/…/…’ 改写成 函数形式 const xxx =()=&gt;import ‘../../…’ 用到时候才想后台请求相关代码</p>
<h2 id="VUE-解决浏览器兼容性问题"><a href="#VUE-解决浏览器兼容性问题" class="headerlink" title="VUE 解决浏览器兼容性问题"></a>VUE 解决浏览器兼容性问题</h2><p>Es6 语法 如 promise 等不支持,可以安装 babel-polyfill 来解决,简单来讲 polyfill 相对于浏览器补丁,通过对浏览器一些 api 的补充达到实现支持原本不支持的 es6 语法的目的,</p>
<p>Vue-cli2 是安装依赖后在 main.js 中引入后,在配置文件中配置代码,</p>
<p>Vue-cli3 是安装依赖后再 vue.config.js 中配置 chainWebpack 的相关代码</p>
<h2 id="Vue-导航守卫有几个钩子函数"><a href="#Vue-导航守卫有几个钩子函数" class="headerlink" title="Vue 导航守卫有几个钩子函数"></a>Vue 导航守卫有几个钩子函数</h2><p>全局的</p>
<p>beforeEach 前置钩子,在进入前干什么</p>
<p>afterEach 后置钩子 ,进去后干什么</p>
<p>BeforeResolve 解析守卫钩子</p>
<p>单个路由的独享守卫钩子</p>
<p>beforeEnter 进入路由表中某个路由前做什么</p>
<p>组件的</p>
<p>beforeRouterEnter 进入某个组件前</p>
<p>beforeRouteUpdate 组件复用的时候触发</p>
<p>beforeRouteLeave 离开组件</p>
<h2 id="路由导航的执行顺序"><a href="#路由导航的执行顺序" class="headerlink" title="路由导航的执行顺序"></a>路由导航的执行顺序</h2><p>1 导航被触发</p>
<p>2 在失活组件中调用 beforeRouteLeave 守卫</p>
<p>3 调用全局 beforeEach 守卫</p>
<p>4 在重用组件的里调用 beforeRouteUpdate 守卫</p>
<p>5 在路由配置里调用 beforeEnter 守卫</p>
<p>6 解析异步路由组件</p>
<p>7 在被激活的组件里调用 beforeRouteEnter</p>
<p>8 调用全局的 beforeResolve 守卫 全局解析守卫</p>
<p>9 导航被确认</p>
<p>10 调用全局的 afterEach 守卫</p>
<p>11 触发 DOM 更新</p>
<p>12 用创建好的实例调用 beforeRouterEnter 守卫中传给 next 的回调函数</p>
<h2 id="Vue-的-use-方法"><a href="#Vue-的-use-方法" class="headerlink" title="Vue 的 use 方法"></a>Vue 的 use 方法</h2><p>和插件内的封装暴露出的 install 方法有关,有暴露出 install 方法就要去 use 去初始化这个插件(调用),这样写的好处就是插件需要一开始调用的方法都封装在 install 里面，更加精简和可拓展性更高。</p>
<p>如果封装的插件是靠这个对象去调用方法，比如 axios，那么直接用的就是 export default 暴露出一个对象，那么就不需要使用 Vue.use。</p>
<h2 id="vue-的-watcher"><a href="#vue-的-watcher" class="headerlink" title="vue 的 watcher"></a>vue 的 watcher</h2><p>normal-watcher 我们在 watch 定义的,都属于这种类型,监听的属性变化了,都会触发定义好的回调函数</p>
<p>computed-watcher 每一个 computed 属性都会生成一个对应的 watcher 对象,具备懒计算的特性,只有用到了才会去计算</p>
<p>render-watcher 每一个组件都会有一个 ,当 data,computed 中的属性改变的时候,会调用他来更新组件的视图</p>
<p>三种顺序: computed-watcher—-normal-watcher——render-watcher</p>
<p>这样就能尽可能的保证，在更新组件视图的时候，computed 属性已经是最新值了，如果 render-watcher 排在 computed-render 前面，就会导致页面更新的时候 computed 值为旧数据。</p>
<h2 id="Vue-组件中的-data-为什么是函数"><a href="#Vue-组件中的-data-为什么是函数" class="headerlink" title="Vue 组件中的 data 为什么是函数"></a>Vue 组件中的 data 为什么是函数</h2><p>目的是为了组件实例间 data 的数据是独有的,</p>
<p>因为组件是可复用的,多个地方多个实例,如果 data 是对象,那么数据是共享的,不能保证组件间数据的独享</p>
<h2 id="Vue-中操作-dom"><a href="#Vue-中操作-dom" class="headerlink" title="Vue 中操作 dom"></a>Vue 中操作 dom</h2><p>$event ref 原生方法获取</p>
<h2 id="vue-中的修饰符"><a href="#vue-中的修饰符" class="headerlink" title="vue 中的修饰符"></a>vue 中的修饰符</h2><p>事件修饰符 .stop .prevent .once .self .capture(实现捕获触发事件的机制)</p>
<p>.stop 是阻止除自己之外所有的冒泡事件,.self 是控制自己被点击才会触发事件处理函数,阻止自己被冒泡影响</p>
<h2 id="Vue-自定义指令的钩子函数和参数"><a href="#Vue-自定义指令的钩子函数和参数" class="headerlink" title="Vue 自定义指令的钩子函数和参数"></a>Vue 自定义指令的钩子函数和参数</h2><p>Vue.directive(指令名,指令配置项)</p>
<p>五个钩子函数 bind inserted update componentUpdated unbind</p>
<p>钩子函数参数 el 指令所在的元素 binding 是是一个包含指令相关信息的对象</p>
<p>name 指令名字 value 指令值 arg 指令参数 modifiers 指令修饰符</p>
<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>Vue.directive(‘focus’,{配置对象})</p>
<p>bind 只会调用一次 inserted 插入到父节点时调用 update 指令值发生改变时 componentUpdated 所有 dom 元素 及其子元素 unbind 指令和所在的元素解绑时调用</p>
<p>参数 1:el 指令所在的 dom 元素</p>
<p>参数 2: binding 是一个对象,包含了指令的相关信息</p>
<p>name:指令名</p>
<p>​ value:指令值</p>
<p>​ arg:指令参数</p>
<p>​ modifiers: 指令修饰符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v-color:font.italic.bold=<span class="string">"fontColor"</span></span><br><span class="line">	v-指令名:指令参数.指令修饰符.指令修饰符=指令值</span><br></pre></td></tr></table></figure>

<h2 id="keep-alive-组件"><a href="#keep-alive-组件" class="headerlink" title="keep-alive 组件"></a>keep-alive 组件</h2><p>keep-alive 是 vue 内置组件,当他动态包裹组件时,会缓存不活动的组件实例,而不是销毁他们,它自身不会渲染成 DOM 元素,</p>
<p>作用是防止重复渲染 DOM,减少加载时间及消耗性能,提高用户体验</p>
<p>keep-alive 的生命周期</p>
<ul>
<li>初次进入时：created &gt; mounted &gt; activated；退出后触发 deactivated</li>
<li>再次进入：会触发 activated；事件挂载的方法等，只执行一次的放在 mounted 中；组件每次进去执行的方法放在 activated 中</li>
<li>include=’test’包裹 test 正则,组件才会缓存, exclude=’test’ 匹配正则的组件都不会被缓存</li>
</ul>
<p>keep-alive 项目实践</p>
<p><strong>1.更改 App.vue</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">'wrapper'</span>&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">        &lt;!-- 需要缓存的视图组件 --&gt;</span><br><span class="line">        &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;&lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>keep-alive&gt;</span><br><span class="line">      &lt;!-- 不需要缓存的视图组件 --&gt;</span><br><span class="line">     &lt;router-view v-<span class="keyword">if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;&lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2.在路由中设置 keepAlive</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'list'</span>,</span><br><span class="line">  name: <span class="string">'itemList'</span>, <span class="comment">// 商品管理</span></span><br><span class="line">  component (resolve) &#123;</span><br><span class="line">    <span class="built_in">require</span>([<span class="string">'@/pages/item/list'</span>], resolve)</span><br><span class="line"> &#125;,</span><br><span class="line"> meta: &#123;</span><br><span class="line">  keepAlive: <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.更改 beforeEach 钩子</strong></p>
<p>这一步是为了清空无用的页面缓存。 假设现在 A、B 两个页面都开启的缓存：</p>
<ul>
<li>若第一次进入 A 页面后退出，再次进入页面时，页面不会刷新。这和目前的业务逻辑不符。我们想要的结果是 A 页面前进后返回，页面保持不变，而不是退出后重新进入保持不变。</li>
<li>在进入过 A 页面后进入 B 页面，经过测试后发现，B 页面竟然会显示 A 页面的缓存，尽管 url 已经改变</li>
</ul>
<p>为了解决这个问题，需要判断页面是在前进还是后退。 在 beforeEach 钩子添加代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> toDepth = to.path.split(<span class="string">'/'</span>).length;</span><br><span class="line"><span class="keyword">let</span> fromDepth = <span class="keyword">from</span>.path.split(<span class="string">'/'</span>).length;</span><br><span class="line"><span class="keyword">if</span> (toDepth &lt; fromDepth) &#123;</span><br><span class="line">  <span class="comment">// console.log('back...')</span></span><br><span class="line">  <span class="keyword">from</span>.meta.keepAlive = <span class="literal">false</span>;</span><br><span class="line">  to.meta.keepAlive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录页面滚动位置</p>
<p>keep-alive 并不会记录页面的滚动位置，所以我们在跳转时需要记录当前的滚动位置，在触发 activated 钩子时重新定位到原有位置。 具体设计思路：</p>
<ol>
<li>在 deactivated 钩子中记录当前滚动位置，使用 localStorage：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deactivated () &#123;</span><br><span class="line"> <span class="built_in">window</span>.localStorage.setItem(<span class="keyword">this</span>.key, <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line"> listScrollTop: <span class="keyword">this</span>.scrollTop</span><br><span class="line"> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在 activated 钩子中滚动：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.cacheData = <span class="built_in">window</span>.localStorage.getItem(<span class="keyword">this</span>.key) ？<span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="keyword">this</span>.key)) : <span class="literal">null</span></span><br><span class="line">$(<span class="string">'.sidebar-item'</span>).scrollTop(<span class="keyword">this</span>.cacheData.listScrollTop)</span><br></pre></td></tr></table></figure>

<h2 id="vue-中的混入-mixins"><a href="#vue-中的混入-mixins" class="headerlink" title="vue 中的混入 mixins"></a>vue 中的混入 mixins</h2><p>分发 vue 组件中可复用功能的非常灵活的方式,混入对象可以包含任意组件选项,,当组件使用混入对象时,所有混入对象的选项将被混入该组件本身的选项中</p>
<p>定义一个混入对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myMixin=&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            num:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">	....</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mixins 特点</p>
<p>同一个混入对象在不同组件中使用,</p>
<p>方法和参数(data)在各组件中不共享,</p>
<p>值为对象的选项,如 methods,components 等,会和组件内合并,键冲突的组件会覆盖混入对象中的方法,</p>
<p>值为函数的,如 created 等,会被合并调用,混入对象的在组件之前调用</p>
<h2 id="vue-中的-vdom"><a href="#vue-中的-vdom" class="headerlink" title="vue 中的 vdom"></a>vue 中的 vdom</h2><p>vue2.0 加入了 virtual dom , 使用 vdom 能使用更少的 dom 操作，能减少时间花费，减少性能损耗。</p>
<p>所谓的<strong>Virtual dom</strong>，也就是我们常说的虚拟节点，它是通过<strong>JS</strong>的<strong>Object</strong>对象模拟<strong>DOM</strong>中的节点，然后再通过特定的<strong>render</strong>方法解析 jsx 将其渲染成真实的<strong>DOM</strong>的节点。</p>
<p>diff 算法是一种优化手段，将前后两个模块进行差异化对比, diff 算法运行结束之后，返回一个补丁对象（patch）</p>
<p>DIFF 算法在执行时有三个维度，分别是<strong>Tree DIFF</strong>、<strong>Component DIFF</strong>和<strong>Element DIFF</strong>，执行时按顺序依次执行，它们的差异仅仅因为 DIFF 粒度不同、执行先后顺序不同。</p>
<p>即 vue - 细粒度更新 - 每个数据 = 对应一个 watcher</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-中等粒度更新 - 每个组件 - 对应一个watcher - 每个组件内部使用虚拟DOM;</span><br></pre></td></tr></table></figure>

<h2 id="虚拟-DOM-和-diff-算法"><a href="#虚拟-DOM-和-diff-算法" class="headerlink" title="虚拟 DOM 和 diff 算法"></a>虚拟 DOM 和 diff 算法</h2><p>通过数据加模板,即用 js 来模拟 DOM,形成虚拟 DOM 树, 然后用这个树构建一个真正的 DOM 树,插入到文档中,</p>
<p>数据变化,形成新的虚拟 DOM,新旧虚拟 DOM 通过 diff 算法进行比较,将差异部分更新</p>
<p>diff 算法 两个假定,两个不同类型的元素会产生不同的树,可以通过 key 属性指定不同树中没有发生改变的子元素</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>状态管理工具</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="comment">//挂载Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">//创建VueX对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        <span class="comment">//存放的键值对就是所要管理的状态</span></span><br><span class="line">        name:<span class="string">'helloVueX'</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>state 存放状态</p>
<p>mutations 数据操作 方法函数中默认第一个参数 state,第二个是 payload</p>
<p>getters 相对于计算属性 加工 state 数据</p>
<p>actions 异步操作 方法函数中默认参数 context 上下文,相对于箭头函数中的 this payload 挂载参数</p>
<p>this.$store.state.name 获取数据</p>
<p>this.$store.commit(moutations 中的方法名,参数,{多参数时为对象形式}) 触发 mutations 中的方法</p>
<p>this.$store.getters.fn 方法函数有默认参数 1:state 参数 2:getters 当前 getters 对象，用于将 getters 下的其他 getter 拿来用</p>
<p>this.$store.dispatch (方法名字,{参数对象}) actions 异步方法调用</p>
<p>项目庞大, 状态非常多的时候,可以 modules 模块化管理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">models:&#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        state:&#123;&#125;,</span><br><span class="line">        getters:&#123;&#125;,</span><br><span class="line">        ....</span><br><span class="line">    &#125;,</span><br><span class="line">    b:&#123;</span><br><span class="line">      state:&#123;&#125;,</span><br><span class="line">        getters:&#123;&#125;,</span><br><span class="line">        ....</span><br><span class="line">    &#125;,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>辅助函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以映射一个state属性</span></span><br><span class="line">...mapState([<span class="string">'list'</span>])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 映射方法</span></span><br><span class="line"> ...mapMutations([<span class="string">'delTodo'</span>, <span class="string">'changeState'</span>]),</span><br><span class="line">  <span class="comment">//映射异步方法</span></span><br><span class="line"> ...mapActions([<span class="string">'clearTodoAction'</span>])</span><br><span class="line"><span class="comment">// 使用对象展开运算符将 getters 混入 computed 对象中</span></span><br><span class="line">...mapGetters([</span><br><span class="line">      <span class="string">'countDouble'</span>,</span><br><span class="line">      <span class="string">'CountDoubleAndDouble'</span>,</span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>

<h2 id="vuex-along-持久化存储-state-的-vuex-扩展"><a href="#vuex-along-持久化存储-state-的-vuex-扩展" class="headerlink" title="vuex-along - 持久化存储 state 的 vuex 扩展"></a>vuex-along - 持久化存储 state 的 vuex 扩展</h2><p>​ <strong>常用于刷新网页后自动恢复 state</strong></p>
<h2 id="vue-组件通讯的方式"><a href="#vue-组件通讯的方式" class="headerlink" title="vue 组件通讯的方式"></a>vue 组件通讯的方式</h2><p>三种 props $emit 事件总线bus  外加vuex，存本地  $ref 通信</p>
<p>$ref 着重于索引，主要用来调用子组件里的属性和方法，其实并不擅长数据传递。</p>
<h2 id="Vue-中的-render-函数"><a href="#Vue-中的-render-函数" class="headerlink" title="Vue 中的 render 函数"></a>Vue 中的 render 函数</h2><p>​ render: h =&gt; h(App) 实际上是 render :function (createElement){return createElement(App)}</p>
<p>createElement 函数用来生成一个 VNode 节点,render 函数得到这个 VNode 节点,返回给 Vue.js 的 mount 函数,渲染成真实的 DOM 节点并挂载到根节点上</p>
<h2 id="vue-中-animate-css-使用"><a href="#vue-中-animate-css-使用" class="headerlink" title="vue 中 animate.css 使用"></a>vue 中 animate.css 使用</h2><p>用 transition 标签包裹需要动画的盒子, 自定义动态切换的类名 (6 个) transition 可以设置 name duration</p>
<p>enter-active -class=”animated(动画基础类) 动画名”</p>
<h2 id="watch-和-computed-区别"><a href="#watch-和-computed-区别" class="headerlink" title="watch 和 computed 区别"></a>watch 和 computed 区别</h2><p>computed <strong>一个数据受多个数据影响</strong></p>
<p>computed 是计算属性,依赖其他的属性值,并且 computed 的属性值有缓存属性,当属性值变化时,下一次 computed 属性时候才会重新计算 computed 的值</p>
<p>最典型的例子： 购物车商品结算的时候</p>
<p>watch <strong>一个数据影响多个数据</strong></p>
<p>watch 更多的是一种观察的作用,用于监听某些数据的回调,主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,每当所监听的数据变化时才能执行回调处理后续操作,</p>
<p>搜索框 即要存输入内容发送请求用,又要存到搜索记录的数组中</p>
<p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用  watch  选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h2 id="Vue-子组件调用父组件的方法"><a href="#Vue-子组件调用父组件的方法" class="headerlink" title="Vue 子组件调用父组件的方法"></a>Vue 子组件调用父组件的方法</h2><p>第一种 子组件通过 this.$parent.方法 来调用</p>
<p>第二种 父组件通过自定义事件名 子组件通过 this.$emit(自定义事件名)触发 子传父</p>
<p>第三种 父组件把方法传入子组件中, 子组件直接调用</p>
<h2 id="Vue-中-provider-inject"><a href="#Vue-中-provider-inject" class="headerlink" title="Vue 中 provider/inject"></a>Vue 中 provider/inject</h2><p>在父组件中通过 provider 提供变量,在子组件中通过 inject 来注入变量,在子组件中可以给 data 提供属性</p>
<p>提供 父组件在 export default 里添加 provide: {</p>
<p>for: “demo”</p>
<p>},</p>
<p>获取 子组件在 export default 里添加 inject: [‘for’],</p>
<h2 id="项目中遇到的难题"><a href="#项目中遇到的难题" class="headerlink" title="项目中遇到的难题"></a>项目中遇到的难题</h2><p>​ 获取需要的信息 涉及到跨域问题 但公司跨域方法解决不了这个问题,后来使用<a href="https://www.npmjs.com/package/vue-jsonp" target="_blank" rel="noopener">vue-jsonp</a> 猜测专门设置反向代理应该也可以解决</p>
<p>​ Token 解析是分成三部分组成的 头部是加密的字符串等信息,中间部分是我们的信息,最后尾部是一个标识,比如时间戳等内容</p>
<p>还有涉及到 base64 加密,都一样的太普通,需要自己的东西,加上特殊性</p>
<h2 id="解决手机刘海屏问题"><a href="#解决手机刘海屏问题" class="headerlink" title="解决手机刘海屏问题"></a>解决手机刘海屏问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0,viewport-fit=cover"</span>&gt;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">      padding: constant(safe-area-inset-top) constant( safe-area-inset-right ) constant( safe-area-inset-bottom) constant( safe-area-inset-left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rem-布局在部分手机上显示不正常问题"><a href="#rem-布局在部分手机上显示不正常问题" class="headerlink" title="rem 布局在部分手机上显示不正常问题"></a>rem 布局在部分手机上显示不正常问题</h2><p>WebView 是 android 中一个重要的控件,用来展示页面,部分安卓手机或者 Webview 调整了系统默认字体大小,所有 rem 布局时,根元素字体大小就会不准确,导致 rem 计算错误</p>
<p>​ <a href="https://blog.csdn.net/weixin_33766805/article/details/92021954" target="_blank" rel="noopener">三个解决步骤详解</a></p>
<p>1、计算实际字号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> actualSize = <span class="built_in">parseFloat</span>(<span class="built_in">window</span>.getComputedStyle(<span class="built_in">document</span>.documentElement)[<span class="string">'font-size'</span>]);</span><br></pre></td></tr></table></figure>

<p>2、计算缩放比例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scale = actualSize / rem; <span class="comment">//rem为原本设置的根节点字号</span></span><br></pre></td></tr></table></figure>

<p>3、为保持页面其它元素不受影响，直接缩放 rem：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> remScaled = rem / scale;</span><br></pre></td></tr></table></figure>

<h2 id="video-和-audio-在-ios-上不能自动播放"><a href="#video-和-audio-在-ios-上不能自动播放" class="headerlink" title="video 和 audio 在 ios 上不能自动播放"></a>video 和 audio 在 ios 上不能自动播放</h2><p>加 muted 可以实现静音自动播放, 如果要实现自动播放 得去主动调用 可以加一个播放按钮 监听其 click 事件 调用 video.play()</p>
<h2 id="vue-组件添加事件-click-native"><a href="#vue-组件添加事件-click-native" class="headerlink" title="vue 组件添加事件@click.native"></a>vue 组件添加事件@click.native</h2><p>1，给<a href="https://www.baidu.com/s?wd=vue&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">vue</a>组件绑定事件时候，必须加上 native ，否则会认为监听的是来自 Item 组件自定义的事件</p>
<p>2，等同于在子组件中： 子组件内部处理<a href="https://www.baidu.com/s?wd=click%E4%BA%8B%E4%BB%B6&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">click 事件</a>然后向外发送 click 事件：$emit(“click”.fn)</p>
<h2 id="项目中的遇到的-bug"><a href="#项目中的遇到的-bug" class="headerlink" title="项目中的遇到的 bug"></a>项目中的遇到的 bug</h2><p>1.点击穿透的问题 用 fastclick 处理</p>
<p>2.video 在 ios autoplay 没有效果 需要加 muted 可以静音自动播放 或者自己加个播放按钮 点击调用 video.play()</p>
<p>3.手机刘海屏,加一个 meta viewport-fit=”cover” 在添加 padding constant 四个位置的代码</p>
<p>4.给组件绑定事件不能生效, 需要加上.native 否则会认为是来自该组件内部自定义的事件</p>
<p>5vue 项目中使用 swiper 插件遇到的坑</p>
<p>​ 使用静态数据页面可以正常滑动,使用动态数据时,页面无法滑动,数据显示不正常—- 添加 observer:true</p>
<p>​ 使用 v-if,让 swiper 动态显示的时候,swiper 界面混乱且无法切换——– 添加 observerParents:true</p>
<p>​ swiper 中尽量使用 v-show 不要用 v-if</p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=https://sakura18017.github.io/2020/11/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB1/>https://sakura18017.github.io/2020/11/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB1/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-11-21T18:39:54+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Nov 21, 2020</p>
  </a>
</div>

        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://sakura18017.github.io/2020/11/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB1/&title=面试题汇总1 - Along-Blog&summary=CSS3,HTML5 新增属性Css3:border-color 边框颜色, box-shadow 边框阴影, back ground-size 背景图片大小(cover,contain) , text-shadow,文本阴影 transform 变换, animation 动画, transition 过渡
Html5:video ,audio, localStorage 和 sessionStorage , 新增表单类型标签:email url number , 表单属性 form , 语义化标签:article , aside , header , footer"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://sakura18017.github.io/2020/11/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB1/&title=面试题汇总1 - Along-Blog&summary=CSS3,HTML5 新增属性Css3:border-color 边框颜色, box-shadow 边框阴影, back ground-size 背景图片大小(cover,contain) , text-shadow,文本阴影 transform 变换, animation 动画, transition 过渡
Html5:video ,audio, localStorage 和 sessionStorage , 新增表单类型标签:email url number , 表单属性 form , 语义化标签:article , aside , header , footer"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://sakura18017.github.io/2020/11/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB1/&title=面试题汇总1 - Along-Blog&summary=CSS3,HTML5 新增属性Css3:border-color 边框颜色, box-shadow 边框阴影, back ground-size 背景图片大小(cover,contain) , text-shadow,文本阴影 transform 变换, animation 动画, transition 过渡
Html5:video ,audio, localStorage 和 sessionStorage , 新增表单类型标签:email url number , 表单属性 form , 语义化标签:article , aside , header , footer"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,666">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2020/11/24/test/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>test</p>
          <p class='content'></p>
        </a>
      
      
        <a class='next' href='/2020/11/15/web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/'>
          <p class='title'>web前端面试题整理<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>####浏览器兼容问题
IE浏览器对h5语义化标签不支持
浏览器之间对一些css的支持
移动端兼容，主要是用rem对移动端进行适配
ES6新语法的兼容
跨域问题两种：
JSONP：使用scrip...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS3-HTML5-新增属性"><span class="toc-text">CSS3,HTML5 新增属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC"><span class="toc-text">BFC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Es6-新特性"><span class="toc-text">Es6 新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型有哪几种"><span class="toc-text">数据类型有哪几种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js-语言是什么-特性是什么"><span class="toc-text">Js 语言是什么 特性是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是闭包？"><span class="toc-text">什么是闭包？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哪些会造成内存泄漏"><span class="toc-text">哪些会造成内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎样避免内存泄露"><span class="toc-text">怎样避免内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#圣杯布局的实现方式"><span class="toc-text">圣杯布局的实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#盒子的垂直水平居中方式"><span class="toc-text">盒子的垂直水平居中方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是原型链"><span class="toc-text">什么是原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深拷贝浅拷贝及其实现方法有哪些"><span class="toc-text">深拷贝浅拷贝及其实现方法有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取-dom-的方式"><span class="toc-text">获取 dom 的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#父子组件嵌套的渲染顺序"><span class="toc-text">父子组件嵌套的渲染顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#页面渲染的过程："><span class="toc-text">页面渲染的过程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点击拨打电话"><span class="toc-text">点击拨打电话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#element-UI-输入框联想组件"><span class="toc-text">element-UI 输入框联想组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何阻止冒泡"><span class="toc-text">如何阻止冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻止-a-标签的默认行为"><span class="toc-text">阻止 a 标签的默认行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#on-和-addeventlister-的区别"><span class="toc-text">on 和 addeventlister 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件委托"><span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浮动和定位的区别"><span class="toc-text">浮动和定位的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort-排序的原理-冒泡排序-其他排序方法"><span class="toc-text">sort 排序的原理, 冒泡排序 其他排序方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Typeof-和-instanceof-区别"><span class="toc-text">Typeof 和 instanceof 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#valueOf-和-toString"><span class="toc-text">.valueOf()和.toString()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-指向问题"><span class="toc-text">this 指向问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-干了哪些事"><span class="toc-text">new 干了哪些事</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#var-let-const-区别"><span class="toc-text">var let const 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承的方式"><span class="toc-text">继承的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#横向越权与纵向越权"><span class="toc-text">横向越权与纵向越权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何防止横向越权漏洞："><span class="toc-text">如何防止横向越权漏洞：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何防止纵向越权漏洞："><span class="toc-text">如何防止纵向越权漏洞：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#节流和防抖"><span class="toc-text">节流和防抖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四种定时器"><span class="toc-text">四种定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是前后端分离及怎么去实施前后端分离"><span class="toc-text">什么是前后端分离及怎么去实施前后端分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组拍平-数组降维"><span class="toc-text">数组拍平(数组降维)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canvas-和-svg-区别"><span class="toc-text">Canvas 和 svg 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预防-xss-攻击"><span class="toc-text">预防 xss 攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#防御-CSRF-攻击"><span class="toc-text">防御 CSRF 攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数没有自己的-this-和-arguments"><span class="toc-text">箭头函数没有自己的 this 和 arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flex-的三个属性"><span class="toc-text">flex 的三个属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-map-和-set"><span class="toc-text">ES6 map 和 set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#For-in-循环和-for-of-循环的区别"><span class="toc-text">For in 循环和 for of 循环的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-entries-和-reduce-方法"><span class="toc-text">Object.entries() 和 reduce()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-assign"><span class="toc-text">Object.assign()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跨域"><span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反向代理-解决跨域"><span class="toc-text">反向代理 (解决跨域)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-lazyload-图片懒加载"><span class="toc-text">vue-lazyload 图片懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器兼容问题"><span class="toc-text">浏览器兼容问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提高页面的渲染性能？"><span class="toc-text">提高页面的渲染性能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDN-优化问题"><span class="toc-text">CDN 优化问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-和-https-协议"><span class="toc-text">http 和 https 协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http1-和-http2-区别"><span class="toc-text">http1 和 http2 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket-协议"><span class="toc-text">websocket 协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RESTful-接口规范"><span class="toc-text">RESTful 接口规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-协议相关内容-地址栏发生改变发生了什么"><span class="toc-text">http 协议相关内容-地址栏发生改变发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三次握手"><span class="toc-text">三次握手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-缓存和浏览器缓存"><span class="toc-text">http 缓存和浏览器缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端渲染-SSR-和客户端渲染的区别"><span class="toc-text">服务端渲染 SSR 和客户端渲染的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图片过多时优化"><span class="toc-text">图片过多时优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩图片"><span class="toc-text">压缩图片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图片分块上传"><span class="toc-text">图片分块上传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开启-Gzip-压缩"><span class="toc-text">开启 Gzip 压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax-和-axios-怎么撤回"><span class="toc-text">ajax 和 axios 怎么撤回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax-设置-token"><span class="toc-text">ajax 设置 token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步操作的常见语法"><span class="toc-text">异步操作的常见语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios-和-ajax-区别-优缺点"><span class="toc-text">axios 和 ajax 区别 优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-和-await"><span class="toc-text">async 和 await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多个-async-和-await-会造成加载慢的问题"><span class="toc-text">多个 async 和 await 会造成加载慢的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scss-和-less-区别-优缺点"><span class="toc-text">scss 和 less 区别,优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack"><span class="toc-text">webpack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack-dev-server"><span class="toc-text">webpack-dev-server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack-和-gulp-的区别"><span class="toc-text">webpack 和 gulp 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loader-和-plugin-区别"><span class="toc-text">loader 和 plugin 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#env-文件配置"><span class="toc-text">.env 文件配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dependencies-和-devDependencies-区别"><span class="toc-text">dependencies 和 devDependencies 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-cli-打包后白屏-资源路径为绝对路径-需要将所有资源改为相对路径"><span class="toc-text">Vue-cli 打包后白屏,资源路径为绝对路径,需要将所有资源改为相对路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-项目打包成移动端-APP"><span class="toc-text">Vue 项目打包成移动端 APP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么通常在发送数据埋点请求时使用-gif-图片"><span class="toc-text">为什么通常在发送数据埋点请求时使用 gif 图片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-的原理"><span class="toc-text">Vue 的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-的双向数据绑定原理"><span class="toc-text">Vue 的双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#观察者模式-Observer-和发布-Publish-订阅者-Subscribe-区别"><span class="toc-text">观察者模式(Observer)和发布(Publish)&#x2F;订阅者(Subscribe)区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-的路由实现原理"><span class="toc-text">Vue 的路由实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-有什么缺点"><span class="toc-text">Vue 有什么缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3-0-新特性"><span class="toc-text">vue3.0 新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-的生命周期函数"><span class="toc-text">Vue 的生命周期函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-路由组件懒加载"><span class="toc-text">vue 路由组件懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VUE-解决浏览器兼容性问题"><span class="toc-text">VUE 解决浏览器兼容性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-导航守卫有几个钩子函数"><span class="toc-text">Vue 导航守卫有几个钩子函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路由导航的执行顺序"><span class="toc-text">路由导航的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-的-use-方法"><span class="toc-text">Vue 的 use 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-的-watcher"><span class="toc-text">vue 的 watcher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-组件中的-data-为什么是函数"><span class="toc-text">Vue 组件中的 data 为什么是函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-中操作-dom"><span class="toc-text">Vue 中操作 dom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-中的修饰符"><span class="toc-text">vue 中的修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-自定义指令的钩子函数和参数"><span class="toc-text">Vue 自定义指令的钩子函数和参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义指令"><span class="toc-text">自定义指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive-组件"><span class="toc-text">keep-alive 组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-中的混入-mixins"><span class="toc-text">vue 中的混入 mixins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-中的-vdom"><span class="toc-text">vue 中的 vdom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟-DOM-和-diff-算法"><span class="toc-text">虚拟 DOM 和 diff 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex"><span class="toc-text">Vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex-along-持久化存储-state-的-vuex-扩展"><span class="toc-text">vuex-along - 持久化存储 state 的 vuex 扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-组件通讯的方式"><span class="toc-text">vue 组件通讯的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-中的-render-函数"><span class="toc-text">Vue 中的 render 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-中-animate-css-使用"><span class="toc-text">vue 中 animate.css 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch-和-computed-区别"><span class="toc-text">watch 和 computed 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-子组件调用父组件的方法"><span class="toc-text">Vue 子组件调用父组件的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-中-provider-inject"><span class="toc-text">Vue 中 provider&#x2F;inject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目中遇到的难题"><span class="toc-text">项目中遇到的难题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决手机刘海屏问题"><span class="toc-text">解决手机刘海屏问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rem-布局在部分手机上显示不正常问题"><span class="toc-text">rem 布局在部分手机上显示不正常问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#video-和-audio-在-ios-上不能自动播放"><span class="toc-text">video 和 audio 在 ios 上不能自动播放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-组件添加事件-click-native"><span class="toc-text">vue 组件添加事件@click.native</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目中的遇到的-bug"><span class="toc-text">项目中的遇到的 bug</span></a></li></ol>
    </div>
  </section>


  


</aside>



        
        
          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="面试题汇总1";
  pdata.commentPath="";
  pdata.commentPlaceholder="";

  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
</script>

        
      </div>
      
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.1.6" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


      <a id="s-top" class="fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
  </div>
  <div>
    <script>
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/********************脚本懒加载函数********************************/
function loadScript(src, cb) {
var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
var script = document.createElement('script');
script.setAttribute('type','text/javascript');
if (cb) script.onload = cb;
script.setAttribute('src', src);
HEAD.appendChild(script);
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    setTimeout(function() {
      loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
    }, 1);
  };
  $(function () {
    SCload_fancybox();
  });
</script>


<!-- internal -->







  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  
  
    <script>
      window.FPConfig = {
        delay: 0,
        ignoreKeywords: [],
        maxRPS: 5,
        hoverDelay: 25
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
  










  
  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/valine.min.js"></script>


<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;

    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";

    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: pagePlaceholder,
      path: path,
      appId: "",
      appKey: "",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      recordIP: 'false',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>





  
<script src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/app.min.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('https://cdn.jsdelivr.net/npm/hexo-theme-volantis@4.1.6/source/js/search/hexo.min.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://sakura18017.github.io' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://sakura18017.github.io' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://sakura18017.github.io' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#l_cover",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
       

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      
	 

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
          if (typeof $.fancybox == "undefined") {
            SCload_fancybox();
          } else {
            pjax_fancybox();
          }
        
        
        
        
        
        
          pjax_valine();
        
        
        
        
      } catch (e) {
        console.log(e);
      }
	  
    });

    document.addEventListener('pjax:error', function (e) {
	  
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
